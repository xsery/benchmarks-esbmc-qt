/*******************************************************************\
 
 Module: QQSet
 
 Author: Felipe Rodrigues
 
 Date: June 2015
 
 \*******************************************************************/

#ifndef __QSet
#define __QSet

//#include "QList"

#define MAX 500

using namespace std;

namespace std {
    
    template < class Key >
    class QSet {
    public:
        typedef Key& reference;
        typedef const Key& const_reference;
        typedef unsigned int size_type;
        typedef int difference_type;
        typedef Key value_type;
        typedef Key key_type;
        typedef Key* pointer;
        typedef const Key* const_pointer;
        
        Key buf[MAX];
        size_t _size = 0;
        int destructorFlag = 0;
        
        class iterator{
        public:
            int pos;
            key_type* base;
            
            iterator(const iterator& i){
                pos = i.pos;
                base = i.base;
            }
            
            iterator(key_type *bbase, int ppos){
                __ESBMC_assert(bbase!=NULL,"Invalid null pointer");
                pos = ppos;
                base = bbase;
            }
            
            iterator(){
                
            }
            
            iterator& operator=(const iterator& i){
                pos = i.pos;
                base = i.base;
                return *this;
            }
            
            value_type * operator -> (){
                return &base[pos];
            }
            
            value_type & operator * (){
                return base[pos];
            }
            
            iterator& operator ++ (){
                return iterator(base, ++pos);
            }
            iterator operator ++ (int b){
                return iterator(base, pos++);
            }
            
            iterator operator + (int var){
                return iterator(base, pos + var);
            }
            
            iterator& operator -- (){
                return iterator(base, --pos);
            }
            iterator operator -- (int b){
                return iterator(base, pos--);
            }
            
            iterator operator - (int var){
                return iterator(base, pos - var);
            }
            
            bool operator == (const iterator& it) const{
                return ((base == it.base)&&(pos == it.pos));
            }
            
            bool operator != (const iterator& it) const{
                return !((base == it.base)&&(pos == it.pos));
            }
            
            bool operator < (const iterator& it) const{
                return (pos < it.pos);
            }
        };
        
        
        class const_iterator{
        public:
        public:
            int pos;
            key_type* base;
            
            const_iterator(const const_iterator& i){
                pos = i.pos;
                base = i.base;
            }
            
            const_iterator(const iterator& i){
                pos = i.pos;
                base = i.base;
            }
            
            const_iterator(key_type *bbase, int ppos){
                __ESBMC_assert(bbase!=NULL,"Invalid null pointer");
                pos = ppos;
                base = bbase;
            }
            
            const_iterator(){
                
            }
            const_iterator& operator=(const const_iterator& i){
                this->pos = i.pos;
                this->base = i.base;
                return *this;
            }
            
            value_type * operator -> (){
                return &base[pos];
            }
            
            value_type & operator * (){
                return base[pos];
            }
            
            const_iterator& operator ++ (){
                return const_iterator(base, ++pos);
            }
            const_iterator operator ++ (int b){
                return const_iterator(base, pos++);
            }
            
            const_iterator operator + (int var){
                return const_iterator(base, pos + var);
            }
            
            const_iterator& operator -- (){
                return const_iterator(base, --pos);
            }
            const_iterator operator -- (int b){
                return const_iterator(base, pos--);
            }
            
            const_iterator operator - (int var){
                return const_iterator(base, pos - var);
            }
            
            bool operator == (const const_iterator& it) const{
                return ((base == it.base)&&(pos == it.pos));
            }
            bool operator != (const const_iterator& it) const{
                return !((base == it.base)&&(pos == it.pos));
            }
            
            bool operator < (const const_iterator& it) const{
                return (pos < it.pos);
            }
        };
        
        typedef const_iterator ConstIterator;
        typedef iterator Iterator;
        
        QSet() : _size(0){
            _size = 0;
        }
        
        QSet( const QSet<Key>& x ){
            _size = 0;
            for(int i = 0 ; i < x._size ; i++){
                buf[i] = x.buf[i];
            }
            _size = x.size();
            buf[_size] = Key();
        }
        
        void clear(){
            _size = 0;
        }
        
        QSet& operator= ( QSet& x ){
            _size = 0;
            for(int i = 0 ; i < x._size ; i++){
                buf[i] = x.buf[i];
            }
            _size = x.size();
            buf[_size] = Key();
            return *this;
        }
        
        ~QSet(){
            destructorFlag = 1;
        }
        
        // iterators:
        iterator begin(){
            return iterator(buf, 0);
        }
        
        const_iterator begin() const {
            return const_iterator(buf, 0);
        }
        
        const_iterator cbegin() const {
            return const_iterator(buf, 0);
        }
        
        iterator end(){
            iterator buffer;
            buffer.base = &buf[0];
            buffer.pos = _size;
            return buffer;
        }
        
        const_iterator end() const{
            const_iterator buffer;
            buffer.base = &buf[0];
            buffer.pos = _size;
            return buffer;
        }
        
        const_iterator cend() const{
            const_iterator buffer;
            buffer.base = &buf[0];
            buffer.pos = _size;
            return buffer;
        }
        
        const_iterator constBegin() const{
            return const_iterator(buf, 0);
        }
        
        const_iterator constEnd() const{
            const_iterator buffer;
            buffer.base = &buf[0];
            buffer.pos = _size;
            return buffer;
        }
        
        // capacity:
        bool isEmpty() const{
            return (_size==0);
        }
        size_type size() const{
            if(destructorFlag == 1){
                //__ESBMC_assert(0,"Invalid pointer");
            }
            return _size;
        }
        
        // modifiers:
        iterator insert( value_type x ){
            iterator it = begin();
            int i, aux;
            while(it != end()) {
                if(*it == x) {
                    return it;
                }
                it++;
            }
            
            _size++;
            i = _size;
            while(it.pos - 1 < i){
                aux = i +1;
                buf[aux] = buf[i];
                i--;
            }
            
            buf[it.pos] = x;
            return it;
        }
        
        void erase(iterator position){
            __ESBMC_assert( (position.pos >= 0)&&(position.pos < _size),"Invalid argument: iterator out of range" );
            int j;
            for(int i = position.pos + 1; i < _size ; i++){
                j = i - 1;
                buf[j] = buf[i];
            }
            _size--;
            j = _size + 1;
            buf[j] = Key();
        }
        
        // QSet operations:
        
        iterator find(const key_type& x) {
            int i;
            for (i = 0; i != _size; i++)
                if (buf[i] == x)
                    break;
            return iterator(buf,i);
        }
        
        const_iterator find(const key_type& x) const {
            int i;
            for (i = 0; i != _size; i++)
                if (buf[i] == x)
                    break;
            return const_iterator(buf,i);
        }
        
        const_iterator constFind(const key_type& x) const {
            int i;
            for (i = 0; i != _size; i++)
                if (buf[i] == x)
                    break;
            return const_iterator(buf,i);
        }
        
        size_type count() const{
            return _size;
        }
        
        Key& bufElement(int pos ){ //HEEEEEEEEEEEYYYYYY
            return buf[pos];
        }
        
        void swap( QSet<Key>& other ){
            QSet<Key> tmp;
            for(int i = 0; i < other.size(); i++){
                tmp.insert(other.bufElement(i));
            }
            other.clear();
            for(int i = 0; i < this->size(); i++){
                other.insert(this->bufElement(i));
            }
            this->clear();
            for(int i = 0; i < tmp.size(); i++){
                this->insert(tmp.bufElement(i));
            }
        }
     
        int	capacity() const{
            return (this->_size * 2);
        }
        
        bool contains(const Key & value) const{
            for (int i = 0; i < this->_size; i++)
                if (this->buf[i] == value)
                    return true;
            return false;
        }
        
        bool contains(const QSet<Key> & other) const{
            for (int i = 0; i < this->_size; i++)
                if (!(this->contains(other.buf[i])))
                    return false;
            return true;
        }
        
        bool empty() const {
            if (this->_size == 0)
                return true;
            return false;
        }
        
        void	reserve(int size){
            __ESBMC_assert(size > 0,"Invalid position.");
            //CHECK IT
        }
        
        void	squeeze(){
            //TODO
        }
        #if 0
        QList<Key> toList() const{
            QList<Key> __list;
            for (int i = 0; i < this->_size; i++)
                __list.push_back(this->buf[i]);
            return __list;
        }
        #endif
        bool remove(const Key & value){
            bool __flag = false;
            for (int i = 0; i < this->_size; i++) {
                if (this->buf[i] == value) {
                    __flag = true;
                    for (int j = i; j < this->_size - 1; j++) {
                        this->buf[j] = this->buf[j + 1];
                    }
                    this->_size--;
                }
            }
            return __flag;
        }
        
        QSet<Key> & intersect(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (!(other.contains(this->buf[i])))
                    this->remove(this->buf[i]);
            return *this;
        }
        
        QSet<Key>& subtract(const QSet<Key>& other){
            for (int i = 0; i < this->_size; i++)
                if (other.contains(this->buf[i]))
                    this->remove(this->buf[i]);
            return *this;
        }
        
        QSet<Key> & unite(const QSet<Key>& other){
            for (int i = 0; i < this->_size; i++)
                if (!(other.contains(this->buf[i])))
                    this->insert(this->buf[i]);
            return *this;
        }
        /*
        QList<Key> QSet::values() const{
            return this->toList();
        }
        */
        bool	operator!=(const QSet<Key> & other) const{
            if (this->_size != other._size)
                return true;
            for (int i = 0; i < this->_size; i++)
                if (!(this->buf[i] == other.buf[i]))
                    return true;
            return false;
        }
        
        QSet<Key>	operator+(const QSet<Key> & other) const{
            QSet<Key> _tmp;
            int i = 0;
            for (; i < this->_size; i++)
                _tmp.buf[i] = this->buf[i];
            for (int j = 0; j < other._size; j++, i++) {
                _tmp.buf[i] = other.buf[j];
            }
            return _tmp;
        }
        
        QSet<Key> &	operator+=(const QSet<Key> & other){
            int i = this->_size;
            for (int j = 0; j < other._size; j++, i++) {
                this->insert(other.buf[j]);
            }
            return *this;
        }
        
        QSet<Key> &	operator+=(const Key & value){
            this->insert(value);
            return *this;
        }
        
        QSet<Key> &	operator<<(const Key & value){
            this->insert(value);
            return *this;
        }
        
        QSet<Key> &	operator=(const QSet<Key> & other){
            this->clear();
            for (int i = 0; i < other._size; i++)
                this->insert(other.buf[i]);
            return *this;
        }
        
        QSet<Key>	operator=(QSet<Key> && other){
            //TODO
        }
        
        bool	operator==(const QSet<Key> & other) const{
            if (this->_size != other._size)
                return false;
            for (int i = 0; i < this->_size; i++)
                if (!(this->buf[i] == other.buf[i]))
                    return false;
            return true;
        }
        
        QSet<Key>	operator&(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (!(other.contains(this->buf[i])))
                    this->remove(this->buf[i]);
            return *this;
        }
        
        QSet<Key> &	operator&=(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (!(other.contains(this->buf[i])))
                    this->remove(this->buf[i]);
            return *this;
        }
        
        QSet<Key> &	operator&=(const Key & value){
            this->remove(value);
            return *this;
        }
        
        QSet<Key>	operator-(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (other.contains(this->buf[i]))
                    this->remove(this->buf[i]);
            return *this;
        }
        
        QSet<Key> &	operator-=(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (other.contains(this->buf[i]))
                    this->remove(this->buf[i]);
            return *this;
        }
        
        QSet<Key> &	operator-=(const Key & value){
            this->remove(value);
            return *this;
        }
        
        QSet<Key>	operator|(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (!(other.contains(this->buf[i])))
                    this->insert(this->buf[i]);
            return *this;
        }
        
        QSet<Key> &	operator|=(const QSet<Key> & other){
            for (int i = 0; i < this->_size; i++)
                if (!(other.contains(this->buf[i])))
                    this->insert(this->buf[i]);
            return *this;
        }
        
        QSet<Key> &	operator|=(const Key & value){
            if (!(this->contains(value)))
                this->insert(value);
                return *this;
        }
        
    };
    
}

#endif
