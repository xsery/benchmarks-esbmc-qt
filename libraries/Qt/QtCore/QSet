/*******************************************************************\

Module: QQSet

Author: Felipe Rodrigues

Date: June 2015

\*******************************************************************/

#ifndef __STL_QQSet
#define __STL_QQSet

#define MAX 500

#include "../../definitions.h"
#include "../../utility"
#include "../../iterator"
#include "../../iostream"
#include "../../algorithm"
#include "../../functional"

using namespace std;

namespace std {

template < class Key >
class QSet {
public:
	Key buf[MAX];
	size_t _size = 0;
    int destructorFlag = 0;

	// types:

	typedef Key key_type;
	typedef Key value_type;

	typedef int size_type;
	typedef int difference_type;

	class iterator{
	public:
		int pos;
		key_type* base;

		iterator(const iterator& i){
			pos = i.pos;
			base = i.base;
		}

		iterator(key_type *bbase, int ppos){
			__ESBMC_assert(bbase!=NULL,"Invalid null pointer");
			pos = ppos;
			base = bbase;
		}

		iterator(){

		}

		iterator& operator=(const iterator& i){
			pos = i.pos;
			base = i.base;
			return *this;
		}

		value_type * operator -> (){
			return &base[pos];
		}

		value_type & operator * (){
			return base[pos];
		}

		iterator& operator ++ (){
			return iterator(base, ++pos);
		}
		iterator operator ++ (int b){
			return iterator(base, pos++);
		}

		iterator operator + (int var){
			return iterator(base, pos + var);
		}

		iterator& operator -- (){
			return iterator(base, --pos);
		}
		iterator operator -- (int b){
			return iterator(base, pos--);
		}

		iterator operator - (int var){
			return iterator(base, pos - var);
		}

		bool operator == (const iterator& it) const{
			return ((base == it.base)&&(pos == it.pos));
		}

		bool operator != (const iterator& it) const{
			return !((base == it.base)&&(pos == it.pos));
		}

		bool operator < (const iterator& it) const{
			return (pos < it.pos);
		}
	};


	class const_iterator{
	public:
	public:
		int pos;
		key_type* base;

		const_iterator(const const_iterator& i){
			pos = i.pos;
			base = i.base;
		}

		const_iterator(const iterator& i){
			pos = i.pos;
			base = i.base;
		}

		const_iterator(key_type *bbase, int ppos){
			__ESBMC_assert(bbase!=NULL,"Invalid null pointer");
			pos = ppos;
			base = bbase;
		}

		const_iterator(){

		}
		const_iterator& operator=(const const_iterator& i){
			this->pos = i.pos;
			this->base = i.base;
                        return *this;
		}

		value_type * operator -> (){
			return &base[pos];
		}

		value_type & operator * (){
			return base[pos];
		}

		const_iterator& operator ++ (){
			return const_iterator(base, ++pos);
		}
		const_iterator operator ++ (int b){
			return const_iterator(base, pos++);
		}

		const_iterator operator + (int var){
			return const_iterator(base, pos + var);
		}

		const_iterator& operator -- (){
			return const_iterator(base, --pos);
		}
		const_iterator operator -- (int b){
			return const_iterator(base, pos--);
		}

		const_iterator operator - (int var){
			return const_iterator(base, pos - var);
		}

		bool operator == (const const_iterator& it) const{
			return ((base == it.base)&&(pos == it.pos));
		}
		bool operator != (const const_iterator& it) const{
			return !((base == it.base)&&(pos == it.pos));
		}

		bool operator < (const const_iterator& it) const{
			return (pos < it.pos);
		}
	};

    typedef const_iterator ConstIterator;
    typedef iterator Iterator;
#if 0
	explicit QSet ( Key v1[] , Key* v2 ){
		__ESBMC_assert(v2 > v1, "Invalid pointer range: the second argument must be greater than the first one");
		_size = 0;
		int i = 0;
		while(v1 != v2)
			buf[i++] = *v1++;
		_size = i ;
		std::sort(buf,buf+_size/*,rule*/);
	}

	template<class Iterator>
	explicit QSet ( Iterator first , Iterator last ){
		__ESBMC_assert( first< last, "Invalid iterator range: the second argument must be greater than the first one");
		_size = 0;
		int i = 0;
		while(first != last){
			buf[i] = *first;
			i++;
			first++;
		}
		_size = i ;
		std::sort(buf,buf+_size/*,rule*/);
	}
#endif

	QSet() : _size(0){
		_size = 0;
	}

	QSet ( const QSet& x ){
		_size = 0;
		for(int i = 0 ; i < x._size ; i++){
			buf[i] = x.buf[i];
		}
		_size = x.size();
		buf[_size] = 0;
	}

	void clear(){
		_size = 0;
	}

	QSet& operator= ( QSet& x ){
		_size = 0;
		for(int i = 0 ; i < x._size ; i++){
			buf[i] = x.buf[i];
		}
		_size = x.size();
		buf[_size] = Key();
		return *this;
	}

	~QSet(){
		destructorFlag = 1;
	}
	// iterators:
	iterator begin(){
		return iterator(buf, 0);
	}

	iterator end(){
		iterator buffer;
		buffer.base = &buf[0];
		buffer.pos = _size;
		return buffer;
	}

	const_iterator constBegin() const{
		return const_iterator(buf, 0);
	}
	const_iterator constEnd() const{
		const_iterator buffer;
		buffer.base = &buf[0];
		buffer.pos = _size;
		return buffer;
	}

	// capacity:
	bool isEmpty() const{
		return (_size==0);
	}
	size_type size() const{
		if(destructorFlag == 1){
			//__ESBMC_assert(0,"Invalid pointer");
		}
		return _size;
	}

	// modifiers:
	const_iterator insert( value_type x){
		const_iterator it = constBegin();
		int i, aux;
		while(it != end()) {
                  if(*it == x) {
                    return it;
                  }
                  it++;
                }

		_size++;
		i = _size;
		while(it.pos - 1 < i){
			aux = i +1;
			buf[aux] = buf[i];
			i--;
		}

		buf[it.pos] = x;
		return it;
	}

	void erase(iterator position){
		__ESBMC_assert( (position.pos >= 0)&&(position.pos < _size),"Invalid argument: iterator out of range" );
		int j;
		for(int i = position.pos + 1; i < _size ; i++){
			j = i - 1;
			buf[j] = buf[i];
		}
		_size--;
		j = _size + 1;
		buf[j] = Key();
	}

	// QSet operations:

	iterator find(const key_type& x) const {
		int i;
		for (i = 0; i != _size; i++)
			if (buf[i] == x)
				break;
		return iterator(buf,i);
	}

	const_iterator constFind(const key_type& x) const {
		int i;
		for (i = 0; i != _size; i++)
			if (buf[i] == x)
				break;
		return const_iterator(buf,i);
	}

	size_type count() const{
		return _size;
	}

    Key& bufElement(int pos ){
		return buf[pos];
	}
    void swap( QSet<Key>& other ){
		QSet<Key> tmp;
	 	   for(int i = 0; i < other.size(); i++){
     	      tmp.insert(other.bufElement(i));
           }
		   other.clear();
   		   for(int i = 0; i < this->size(); i++){
      		  other.insert(this->bufElement(i));
   		   }
		   this->clear();
   		   for(int i = 0; i < tmp.size(); i++){
      		  this->insert(tmp.bufElement(i));
           }
	}

	iterator upper_bound(const key_type& x) {
		int first = 0, last = _size;
		last--;
		value_type y;
		while(first != last)
		{
			y = buf[first];
			last--;
		}
		return iterator(buf,last);
	}

	const_iterator upper_bound(const key_type& x) const {
		int first = 0, last = _size;
		last--;
		value_type y;
		while(first != last)
		{
			y = buf[first];
			last--;
		}
		return const_iterator(buf,last);
	}
};

}

#endif
